
#include <rtthread.h>
#include <rtdevice.h>
#include "fsl_common.h"
#include "fsl_lpspi_edma.h"
#include "fsl_lpspi.h"

#define HM_CHIP_ADDR       (0x24)

#define HM_DEBUG		0
#if ( HM_DEBUG == 1 )
#include <stdio.h>
#define HM_TRACE	rt_kprintf
#else
#define HM_TRACE(...)
#endif

#define BSP_USING_CAM0
#define BSP_USING_CAM1


static  uint8_t hm0360_init_regtbl[][3]={
		{0x01,0x03,0x00},
		{0x03,0x00,0x0C},
		{0x03,0x02,0xF8},
		{0x03,0x50,0xE0},
		{0x03,0x70,0x01},
		{0x03,0x71,0x01},
		{0x03,0x72,0x00},
		{0x10,0x00,0x43},
		{0x10,0x01,0x80},
		{0x10,0x03,0x20},
		{0x10,0x04,0x20},
		{0x10,0x07,0x01},
		{0x10,0x08,0x20},
		{0x10,0x09,0x20},
		{0x10,0x0A,0x07},
		{0x10,0x0B,0x20},
		{0x10,0x0C,0x20},
		{0x10,0x13,0x00},
		{0x10,0x14,(1<<3)|(1<<1)|(1<<0)},//VSYNC shift
		{0x10,0x18,0x00},
		{0x10,0x1D,0xCF},
		{0x10,0x1E,0x01},
		{0x10,0x1F,0x00},
		{0x10,0x20,0x01},
		{0x10,0x21,0x5D},
		{0x10,0x2F,0x08},
		{0x10,0x30,0x09},
		{0x10,0x31,0x12},
		{0x10,0x32,0x23},
		{0x10,0x33,0x31},
		{0x10,0x34,0x3E},
		{0x10,0x35,0x4B},
		{0x10,0x36,0x56},
		{0x10,0x37,0x5E},
		{0x10,0x38,0x65},
		{0x10,0x39,0x72},
		{0x10,0x3A,0x7F},
		{0x10,0x3B,0x8C},
		{0x10,0x3C,0x98},
		{0x10,0x3D,0xB2},
		{0x10,0x3E,0xCC},
		{0x10,0x3F,0xE6},
		{0x10,0x41,0x00},
		{0x20,0x00,0x7F},
		{0x20,0x2B,0x04},
		{0x20,0x2C,0x03},
		{0x20,0x2D,0x00},
		{0x20,0x31,0x60},
		{0x20,0x32,0x08},
		{0x20,0x36,0x19},
		{0x20,0x37,0x08},
		{0x20,0x38,0x10},
		{0x20,0x3C,0x01},
		{0x20,0x3D,0x04},
		{0x20,0x3E,0x01},
		{0x20,0x3F,0x38},
		{0x20,0x48,0x00},
		{0x20,0x49,0x10},
		{0x20,0x4A,0x40},
		{0x20,0x4B,0x00},
		{0x20,0x4C,0x08},
		{0x20,0x4D,0x20},
		{0x20,0x4E,0x00},
		{0x20,0x4F,0x38},
		{0x20,0x50,0xE0},
		{0x20,0x51,0x00},
		{0x20,0x52,0x1C},
		{0x20,0x53,0x70},
		{0x20,0x54,0x00},
		{0x20,0x55,0x1A},
		{0x20,0x56,0xC0},
		{0x20,0x57,0x00},
		{0x20,0x58,0x06},
		{0x20,0x59,0xB0},
		{0x20,0x61,0x00},
		{0x20,0x62,0x00},
		{0x20,0x63,0xC8},
		{0x20,0x80,0x41},
		{0x20,0x81,0xE0},
		{0x20,0x82,0xF0},
		{0x20,0x83,0x01},
		{0x20,0x84,0x10},
		{0x20,0x85,0x10},
		{0x20,0x86,0x01},
		{0x20,0x87,0x06},
		{0x20,0x88,0x0C},
		{0x20,0x89,0x12},
		{0x20,0x8A,0x1C},
		{0x20,0x8B,0x30},
		{0x20,0x8C,0x10},
		{0x20,0x8D,0x02},
		{0x20,0x8E,0x08},
		{0x20,0x8F,0x0D},
		{0x20,0x90,0x14},
		{0x20,0x91,0x1D},
		{0x20,0x92,0x30},
		{0x20,0x93,0x08},
		{0x20,0x94,0x0A},
		{0x20,0x95,0x0F},
		{0x20,0x96,0x14},
		{0x20,0x97,0x18},
		{0x20,0x98,0x20},
		{0x20,0x99,0x10},
		{0x20,0x9A,0x00},
		{0x20,0x9B,0x01},
		{0x20,0x9C,0x01},
		{0x20,0x9D,0x11},
		{0x20,0x9E,0x06},
		{0x20,0x9F,0x20},
		{0x20,0xA0,0x10},
		{0x25,0x90,0x01},
		{0x28,0x00,0x00},
		{0x28,0x04,0x02},
		{0x28,0x05,0x03},
		{0x28,0x06,0x03},
		{0x28,0x07,0x08},
		{0x28,0x08,0x04},
		{0x28,0x09,0x0C},
		{0x28,0x0A,0x03},
		{0x28,0x0F,0x03},
		{0x28,0x10,0x03},
		{0x28,0x11,0x00},
		{0x28,0x12,0x09},
		{0x28,0x21,0xDE},
		{0x28,0x2A,0x0F},
		{0x28,0x2B,0x08},
		{0x28,0x2E,0x2F},
		{0x30,0x10,0x00},
		{0x30,0x13,0x01},
		{0x30,0x19,0x00},
		{0x30,0x1A,0x00},
		{0x30,0x1B,0x20},
		{0x30,0x1C,0xFF},
		{0x30,0x20,0x00},
		{0x30,0x21,0x00},
		{0x30,0x24,0x00},
		{0x30,0x25,0x12},
		{0x30,0x26,0x03},
		{0x30,0x27,0x81},
		{0x30,0x28,0x01},
		{0x30,0x29,0x00},
		{0x30,0x2A,0x30},
		{0x30,0x2B,0x2A},
		{0x30,0x2C,0x00},
		{0x30,0x2D,0x03},
		{0x30,0x2E,0x00},
		{0x30,0x2F,0x00},
		{0x30,0x31,0x01},
		{0x30,0x34,0x00},
		{0x30,0x35,0x01},
		{0x30,0x51,0x00},
		{0x30,0x5C,0x03},
		{0x30,0x60,0x00},
		{0x30,0x61,0xFA},
		{0x30,0x62,0xFF},
		{0x30,0x63,0xFF},
		{0x30,0x64,0xFF},
		{0x30,0x65,0xFF},
		{0x30,0x66,0xFF},
		{0x30,0x67,0xFF},
		{0x30,0x68,0xFF},
		{0x30,0x69,0xFF},
		{0x30,0x6A,0xFF},
		{0x30,0x6B,0xFF},
		{0x30,0x6C,0xFF},
		{0x30,0x6D,0xFF},
		{0x30,0x6E,0xFF},
		{0x30,0x6F,0xFF},
		{0x30,0x70,0xFF},
		{0x30,0x71,0xFF},
		{0x30,0x72,0xFF},
		{0x30,0x73,0xFF},
		{0x30,0x74,0xFF},
		{0x30,0x75,0xFF},
		{0x30,0x76,0xFF},
		{0x30,0x77,0xFF},
		{0x30,0x78,0xFF},
		{0x30,0x79,0xFF},
		{0x30,0x7A,0xFF},
		{0x30,0x7B,0xFF},
		{0x30,0x7C,0xFF},
		{0x30,0x7D,0xFF},
		{0x30,0x7E,0xFF},
		{0x30,0x7F,0xFF},
		{0x30,0x80,0x00},
		{0x30,0x81,0x00},
		{0x30,0x82,0x00},
		{0x30,0x83,0x20},
		{0x30,0x84,0x00},
		{0x30,0x85,0x20},
		{0x30,0x86,0x00},
		{0x30,0x87,0x20},
		{0x30,0x88,0x00},
		{0x30,0x89,0x04},
		{0x30,0x94,0x02},
		{0x30,0x95,0x02},
		{0x30,0x96,0x00},
		{0x30,0x97,0x02},
		{0x30,0x98,0x00},
		{0x30,0x99,0x02},
		{0x30,0x9E,0x02},//pclk_gated_en
		{0x30,0x9F,0x02},
		{0x30,0xA0,0x00},
		{0x30,0xA1,0x00},//pclk0_line_front_h
		{0x30,0xA2,0x00},//pclk0_line_front_l
		{0x30,0xA3,0x00},//pclk0_line_end_h
		{0x30,0xA4,0x00},//pclk0_line_end_l
		{0x30,0xA5,0x04},
		{0x30,0xA6,0x02},
		{0x30,0xA7,0x02},
		{0x30,0xA8,0x01},
		{0x30,0xA9,0x00},
		{0x30,0xAA,0x02},
		{0x30,0xAB,0x34},
		{0x30,0xB0,0x03},
		{0x30,0xC4,0x10},
		{0x30,0xC5,0x01},
		{0x30,0xC6,0xBF},
		{0x30,0xC7,0x00},
		{0x30,0xC8,0x00},
		{0x30,0xCB,0xFF},
		{0x30,0xCC,0xFF},
		{0x30,0xCD,0x7F},
		{0x30,0xCE,0x7F},
		{0x30,0xD3,0x01},
		{0x30,0xD4,0xFF},
		{0x30,0xD5,0x00},
		{0x30,0xD6,0x40},
		{0x30,0xD7,0x00},
		{0x30,0xD8,0xA7},
		{0x30,0xD9,0x05},
		{0x30,0xDA,0x01},
		{0x30,0xDB,0x40},
		{0x30,0xDC,0x00},
		{0x30,0xDD,0x27},
		{0x30,0xDE,0x05},
		{0x30,0xDF,0x07},
		{0x30,0xE0,0x40},
		{0x30,0xE1,0x00},
		{0x30,0xE2,0x27},
		{0x30,0xE3,0x05},
		{0x30,0xE4,0x47},
		{0x30,0xE5,0x30},
		{0x30,0xE6,0x00},
		{0x30,0xE7,0x27},
		{0x30,0xE8,0x05},
		{0x30,0xE9,0x87},
		{0x30,0xEA,0x30},
		{0x30,0xEB,0x00},
		{0x30,0xEC,0x27},
		{0x30,0xED,0x05},
		{0x30,0xEE,0x00},
		{0x30,0xEF,0x40},
		{0x30,0xF0,0x00},
		{0x30,0xF1,0xA7},
		{0x30,0xF2,0x05},
		{0x30,0xF3,0x01},
		{0x30,0xF4,0x40},
		{0x30,0xF5,0x00},
		{0x30,0xF6,0x27},
		{0x30,0xF7,0x05},
		{0x30,0xF8,0x07},
		{0x30,0xF9,0x40},
		{0x30,0xFA,0x00},
		{0x30,0xFB,0x27},
		{0x30,0xFC,0x05},
		{0x30,0xFD,0x47},
		{0x30,0xFE,0x30},
		{0x30,0xFF,0x00},
		{0x31,0x00,0x27},
		{0x31,0x01,0x05},
		{0x31,0x02,0x87},
		{0x31,0x03,0x30},
		{0x31,0x04,0x00},
		{0x31,0x05,0x27},
		{0x31,0x06,0x05},
		{0x31,0x0B,0x10},
        
        //{0x31,0x0F,(0<<7)},           /* 8bit mode */
        
		{0x31,0x0F,(1<<6)},             /* 4bit mode  (1<<6):4bit, (1<<7):1bir (0) 8bit */

		{0x31,0x12,(1<<3)},             //pclk0_polarity, MSB or LSB 
		{0x31,0x13,0xA0},
		{0x31,0x14,0x67},
		{0x31,0x15,0x42},
		{0x31,0x16,0x10},
		{0x31,0x17,0x0A},
		{0x31,0x18,0x3F},
		{0x31,0x1C,0x10},
		{0x31,0x1D,0x06},
		{0x31,0x1E,0x0F},
		{0x31,0x1F,0x0E},
		{0x31,0x20,0x0D},
		{0x31,0x21,0x0F},
		{0x31,0x22,0x00},
		{0x31,0x23,0x1D},
		{0x31,0x26,0x03},
		{0x31,0x28,0x57},
		{0x31,0x2A,0x11},
		{0x31,0x2B,0x41},
		{0x31,0x2E,0x00},
		{0x31,0x2F,0x00},
		{0x31,0x30,0x0C},
		{0x31,0x41,0x2A},
		{0x31,0x42,0x9F},
		{0x31,0x47,0x18},
		{0x31,0x49,0x18},
		{0x31,0x4B,0x01},
		{0x31,0x50,0x50},
		{0x31,0x52,0x00},
		{0x31,0x56,0x2C},
		{0x31,0x5A,0x0A},
		{0x31,0x5B,0x2F},
		{0x31,0x5C,0xE0},
		{0x31,0x5F,0x02},
		{0x31,0x60,0x1F},
		{0x31,0x63,0x1F},
		{0x31,0x64,0x7F},
		{0x31,0x65,0x7F},
		{0x31,0x7B,0x94},
		{0x31,0x7C,0x00},
		{0x31,0x7D,0x02},
		{0x31,0x8C,0x00},
        
		//{0x35,0x00,((1<<0) | (1<<2))},   //CLK_TB divider 10.24 Contet swtich A registers
        {0x35,0x00,0x0A}, 
  
		{0x35,0x01,0x0A},
		{0x35,0x02,0x77},
		{0x35,0x03,0x02},
		{0x35,0x04,0x14},
		{0x35,0x05,0x03},
		{0x35,0x06,0x00},
		{0x35,0x07,0x01},       //horizontal 0:full, 1:sub2, 2:sub4  0:640x480, 1:320x240, 2:160x120
		{0x35,0x08,0x01},       //vertical   0:full, 1:sub2, 2:sub4
		{0x35,0x09,0x00},// binning operation
		{0x35,0x0A,0xFF},
		{0x35,0x0B,0x01},
		{0x35,0x0C,0x00},
		{0x35,0x0D,0x01},
		{0x35,0x0F,0x00},
		{0x35,0x10,0x01},
		{0x35,0x12,0x7F},
		{0x35,0x13,0x00},
		{0x35,0x14,0x00},
		{0x35,0x15,0x01},
		{0x35,0x16,0x00},
		{0x35,0x17,0x02},
		{0x35,0x18,0x00},
		{0x35,0x19,0x7F},
		{0x35,0x1A,0x00},
		{0x35,0x1B,0x5F},
		{0x35,0x1C,0x00},
		{0x35,0x1D,0x04},
		{0x35,0x1E,0x24},
		{0x35,0x1F,0x04},
		{0x35,0x20,0x03},
		{0x35,0x21,0x00},
		{0x35,0x23,0x60},
		{0x35,0x24,0x08},
		{0x35,0x25,0x19},
		{0x35,0x26,0x08},
		{0x35,0x27,0x10},
		{0x35,0x2A,0x01},
		{0x35,0x2B,0x04},
		{0x35,0x2C,0x01},
		{0x35,0x2D,0x38},
		{0x35,0x35,0x02},
		{0x35,0x36,0x03},
		{0x35,0x37,0x03},
		{0x35,0x38,0x08},
		{0x35,0x39,0x04},
		{0x35,0x3A,0x0C},
		{0x35,0x3B,0x03},
		{0x35,0x40,0x03},
		{0x35,0x41,0x03},
		{0x35,0x42,0x00},
		{0x35,0x43,0x09},
		{0x35,0x49,0x04},
		{0x35,0x4A,0x35},
		{0x35,0x4B,0x21},
		{0x35,0x4C,0x01},
		{0x35,0x4D,0xE0},
		{0x35,0x4E,0xF0},
		{0x35,0x4F,0x10},
		{0x35,0x50,0x10},
		{0x35,0x51,0x10},
		{0x35,0x52,0x20},
		{0x35,0x53,0x10},
		{0x35,0x54,0x01},
		{0x35,0x55,0x06},
		{0x35,0x56,0x0C},
		{0x35,0x57,0x12},
		{0x35,0x58,0x1C},
		{0x35,0x59,0x30},
		//{0x35,0x5A,0x74},
		{0x35,0x5A,0x78},
		{0x35,0x5B,0x0A},
		{0x35,0x5C,0x77},
		{0x35,0x5D,0x01},
		{0x35,0x5E,0x1C},
		{0x35,0x5F,0x03},
		{0x35,0x60,0x00},
		{0x35,0x61,0x01},
		{0x35,0x62,0x01},
		{0x35,0x63,0x03},
		{0x35,0x64,0x55},
		{0x35,0x65,0x01},
		{0x35,0x66,0x00},
		{0x35,0x67,0x01},
		{0x35,0x69,0x00},
		{0x35,0x6A,0x01},
		{0x35,0x6C,0x7F},
		{0x35,0x6D,0x00},
		{0x35,0x6E,0x00},
		{0x35,0x6F,0x01},
		{0x35,0x70,0x00},
		{0x35,0x71,0x02},
		{0x35,0x72,0x00},
		{0x35,0x73,0x3F},
		{0x35,0x74,0x00},
		{0x35,0x75,0x2F},
		{0x35,0x76,0x00},
		{0x35,0x77,0x04},
		{0x35,0x78,0x24},
		{0x35,0x79,0x04},
		{0x35,0x7A,0x03},
		{0x35,0x7B,0x00},
		{0x35,0x7D,0x60},
		{0x35,0x7E,0x08},
		{0x35,0x7F,0x19},
		{0x35,0x80,0x08},
		{0x35,0x81,0x10},
		{0x35,0x84,0x01},
		{0x35,0x85,0x04},
		{0x35,0x86,0x01},
		{0x35,0x87,0x38},
		{0x35,0x88,0x02},
		{0x35,0x89,0x12},
		{0x35,0x8A,0x04},
		{0x35,0x8B,0x24},
		{0x35,0x8C,0x06},
		{0x35,0x8D,0x36},
		{0x35,0x8F,0x02},
		{0x35,0x90,0x03},
		{0x35,0x91,0x03},
		{0x35,0x92,0x08},
		{0x35,0x93,0x04},
		{0x35,0x94,0x0C},
		{0x35,0x95,0x03},
		{0x35,0x9A,0x03},
		{0x35,0x9B,0x03},
		{0x35,0x9C,0x00},
		{0x35,0x9D,0x09},
		{0x35,0xA3,0x02},
		{0x35,0xA4,0x03},
		{0x35,0xA5,0x21},
		{0x35,0xA6,0x01},
		{0x35,0xA7,0xE0},
		{0x35,0xA8,0xF0},
		{0x35,0xA9,0x10},
		{0x35,0xAA,0x10},
		{0x35,0xAB,0x10},
		{0x35,0xAC,0x20},
		{0x35,0xAD,0x10},
		{0x35,0xAE,0x01},
		{0x35,0xAF,0x06},
		{0x35,0xB0,0x0C},
		{0x35,0xB1,0x12},
		{0x35,0xB2,0x1C},
		{0x35,0xB3,0x30},
		{0x35,0xB4,0x74},
		{0x35,0xB5,0x0A},
		{0x35,0xB6,0x77},
		{0x35,0xB7,0x00},
		{0x35,0xB8,0x94},
		{0x35,0xB9,0x03},
		{0x35,0xBA,0x00},
		{0x35,0xBB,0x03},
		{0x35,0xBC,0x03},
		{0x35,0xBD,0x03},
		{0x35,0xBE,0x01},
		{0x35,0xBF,0x01},
		{0x35,0xC0,0x01},
		{0x35,0xC1,0x01},
		{0x35,0xC3,0x00},
		{0x35,0xC4,0x00},
		{0x35,0xC6,0x7F},
		{0x35,0xC7,0x00},
		{0x35,0xC8,0x00},
		{0x35,0xC9,0x01},
		{0x35,0xCA,0x00},
		{0x35,0xCB,0x02},
		{0x35,0xCC,0x00},
		{0x35,0xCD,0x0F},
		{0x35,0xCE,0x00},
		{0x35,0xCF,0x0B},
		{0x35,0xD0,0x00},
		{0x35,0xD3,0x04},
		{0x35,0xD7,0x18},
		{0x35,0xD8,0x01},
		{0x35,0xD9,0x20},
		{0x35,0xDA,0x08},
		{0x35,0xDB,0x14},
		{0x35,0xDC,0x70},
		{0x35,0xDE,0x00},
		{0x35,0xDF,0x01},
		{0x35,0xE9,0x02},
		{0x35,0xEA,0x03},
		{0x35,0xEB,0x03},
		{0x35,0xEC,0x08},
		{0x35,0xED,0x04},
		{0x35,0xEE,0x0C},
		{0x35,0xEF,0x03},
		{0x35,0xF4,0x03},
		{0x35,0xF5,0x03},
		{0x35,0xF6,0x00},
		{0x35,0xF7,0x09},
		{0x35,0xFD,0x00},
		{0x35,0xFE,0x5E},
		{0x01,0x04,0x01},
		{0x01,0x00,0x01},
};



#define DEMO_LPSPI_EDMA_WATERMARK   4U
#define DEMO_LPSPI_EDMA_MAJOR_LINES 240U /* Must be integer counts! */

#define DEMO_LPSPI_RES_HORIZONTAL   320UL
#define DEMO_LPSPI_RES_VERTICAL     240UL
#define DEMO_LPSPI_PIX_SIZE         1U
#define DEMO_LPSPI_LINE_SIZE        (DEMO_LPSPI_RES_HORIZONTAL * DEMO_LPSPI_PIX_SIZE)
#define DEMO_LPSPI_BUFFER_SIZE      (DEMO_LPSPI_LINE_SIZE * DEMO_LPSPI_RES_VERTICAL)

typedef struct 
{
    struct rt_device            parent;
    struct rt_i2c_bus_device    *bus;
    uint8_t                     vsync_pin;
    uint8_t                     chip_addr;
    
    LPSPI_Type                  *LPSPIX;
    DMA_Type                    *DMAX;
    uint32_t                    rx_dma_ch;
    edma_handle_t               dma_rx_handle;
    dma_request_source_t        dma_req_src;
    const char                  *name;
    const char                  *i2c_bus_name;
}cam_device_t;


static  cam_device_t cam_obj[] =
{
#ifdef BSP_USING_CAM0
    {
        .vsync_pin = ((1*32)+11),
        .name = "cam0",
        .i2c_bus_name = "i2c0",
        .LPSPIX = LPSPI5,
        .DMAX = DMA1,
        .rx_dma_ch = 1,
        .dma_req_src = kDmaRequestMuxLpFlexcomm5Rx,
    },
#endif
#ifdef BSP_USING_CAM1
    {
        .vsync_pin = ((1*32)+22),
        .name = "cam1",
        .i2c_bus_name = "i2c1",
        .LPSPIX = LPSPI3,
        .DMAX = DMA1,
        .rx_dma_ch = 2,
        .dma_req_src = kDmaRequestMuxLpFlexcomm3Rx,
    },
#endif
};



static rt_err_t rt_hm_init(rt_device_t dev)
{    
    return RT_EOK;
}


static void pin_irq_vsync(void *args)
{
    cam_device_t *cam = args;
    
    if(cam->parent.rx_indicate)
    {
        cam->parent.rx_indicate((rt_device_t)args, 1);
    }
}

static void lpfc_edma_major_callback(edma_handle_t *handle, void *userData, bool transferDone, uint32_t tcds)
{
    cam_device_t *cam = (cam_device_t *)userData;
    
    if(userData == &cam_obj[0])
    {
      //  rt_kprintf("cam0_dma_done\r\n");
    }

    if(userData == &cam_obj[1])
    {
    //    rt_kprintf("cam1_dma_done\r\n");
    }
  //  DMA0->CH[cam_obj[0].rx_dma_ch].TCD_CSR |= DMA_TCD_CSR_DREQ_MASK;
}



uint32_t cam_start_xfer(rt_device_t dev, uint8_t *buf)
{
    
    cam_device_t *cam = (cam_device_t *)dev;
    /**
     * DMA configuration:
     * Each DMA request will read 4 bytes from LPSPI FIFO
     * Each major loop will copy frame to memory
     * Major loop interrup is not necessary if actual VSYNC is used.
     * DMA maximum supports 131072 (32768 * 4) bytes in a single major loop,
     * this code has no byte count limit by modifying the macro.
     */
    
    LPSPI_DisableDMA(cam->LPSPIX, kLPSPI_RxDmaEnable);
    EDMA_AbortTransfer(&cam->dma_rx_handle);
    
    
    edma_transfer_config_t dma_cfg;

    memset(&dma_cfg, 0x00, sizeof(dma_cfg));
    
    dma_cfg.srcAddr            = LPSPI_GetRxRegisterAddress(cam->LPSPIX);
    dma_cfg.srcTransferSize    = kEDMA_TransferSize1Bytes;
    dma_cfg.srcOffset          = 0;
    dma_cfg.destAddr           = (uint32_t)buf;
    dma_cfg.destTransferSize   = kEDMA_TransferSize4Bytes;
    dma_cfg.destOffset         = 4;
    dma_cfg.minorLoopBytes     = DEMO_LPSPI_EDMA_WATERMARK; /* NBYTES for each DMA request */
    dma_cfg.majorLoopCounts    = (DEMO_LPSPI_LINE_SIZE * DEMO_LPSPI_EDMA_MAJOR_LINES) / DEMO_LPSPI_EDMA_WATERMARK;
    dma_cfg.dstMajorLoopOffset = 0; /* !! DADDR is auto-incremented by hardware, no adjustment needed */

    EDMA_SetTransferConfig(cam->DMAX, cam->rx_dma_ch, &dma_cfg, NULL);
    EDMA_EnableChannelInterrupts(cam->DMAX, cam->rx_dma_ch, kEDMA_MajorInterruptEnable);

    uint32_t tcd_xfer_count = DEMO_LPSPI_RES_VERTICAL / DEMO_LPSPI_EDMA_MAJOR_LINES;

    if (tcd_xfer_count > 1) {
        /* Do not clear request after TCD completed, since we need this channel to be triggered again by request */
        cam->DMAX->CH[cam->rx_dma_ch].TCD_CSR &= ~(DMA_TCD_CSR_DREQ_MASK);
    }

    
    lpspi_slave_config_t slave_cfg;
    LPSPI_SlaveGetDefaultConfig(&slave_cfg);

    slave_cfg.bitsPerFrame       = 8U;
    slave_cfg.whichPcs           = kLPSPI_Pcs0;
    slave_cfg.dataOutConfig      = kLpspiDataOutTristate;
    slave_cfg.pcsFunc            = kLPSPI_PcsAsData;
    slave_cfg.pcsActiveHighOrLow = kLPSPI_PcsActiveHigh;
    slave_cfg.cpha         = kLPSPI_ClockPhaseSecondEdge;
    LPSPI_SlaveInit(cam->LPSPIX, &slave_cfg);
    LPSPI_Enable(cam->LPSPIX, false);
    LPSPI_SetFifoWatermarks(cam->LPSPIX, 0, DEMO_LPSPI_EDMA_WATERMARK - 1);
    LPSPI_FlushFifo(cam->LPSPIX, true, true);
    
    uint32_t tcr = cam->LPSPIX->TCR;

    tcr &= ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK | LPSPI_TCR_BYSW_MASK | LPSPI_TCR_TXMSK_MASK);
    tcr |= LPSPI_TCR_TXMSK(1);
    tcr |= LPSPI_TCR_BYSW(0);
    tcr |= LPSPI_TCR_PCS(0);
    tcr |= LPSPI_TCR_WIDTH(2);

    LPSPI_Enable(cam->LPSPIX, true);

    cam->LPSPIX->TCR = tcr;
    
    EDMA_StartTransfer(&cam->dma_rx_handle);
    LPSPI_EnableDMA(cam->LPSPIX, kLPSPI_RxDmaEnable);

    return RT_EOK;
}



static rt_err_t rt_hm_open(rt_device_t dev, rt_uint16_t oflag)
{
    int i;
    uint8_t val;
    rt_err_t ret;
    
    cam_device_t *cam = (cam_device_t *)dev;
    
    struct rt_i2c_bus_device* bus = cam->bus;
    
    uint8_t buf[2];
    
    buf[0] = 0x00;
    buf[1] = 0x00;
    rt_i2c_master_send(bus, HM_CHIP_ADDR, 0, buf, sizeof(buf));
    rt_i2c_master_recv(bus, HM_CHIP_ADDR, 0, buf, 1);
    
    if(buf[0] == 0x03)
    {
        rt_kprintf("hm0360 found!\r\n", buf[0]);
        
        for(int i=0; i<ARRAY_SIZE(hm0360_init_regtbl); i++)
        {
            rt_i2c_master_send(bus, HM_CHIP_ADDR, 0, &hm0360_init_regtbl[i][0], 3);
        }
    }
    else
    {
        rt_kprintf("hm0360 not found! val:0x%X\r\n", buf[0]);
    }
    

    /* CHn_MUX can not be set again if the specified request is in use. */
    /* Also, the existing requests should be cleared before setting to another channel */
    EDMA_SetChannelMux(cam->DMAX, cam->rx_dma_ch, cam->dma_req_src);
    EDMA_CreateHandle(&cam->dma_rx_handle, cam->DMAX, cam->rx_dma_ch);
    EDMA_SetCallback(&cam->dma_rx_handle, lpfc_edma_major_callback, cam);
    

    
    /* VSYNC */
    rt_pin_mode(cam->vsync_pin, PIN_MODE_INPUT); 
    rt_pin_attach_irq(cam->vsync_pin, PIN_IRQ_MODE_FALLING, pin_irq_vsync, dev);
    rt_pin_irq_enable(cam->vsync_pin, 1);
    

    
    return ret;
}




static rt_ssize_t rt_hm_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size)
{
    cam_device_t *cam = (cam_device_t *)dev;
    return size;
}


static rt_ssize_t rt_hm_write(rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size)
{
    uint8_t *val = (uint8_t *)buffer;
    return 0;
}

int rt_hw_hm0360_init(void)
{
    int i;
    
    for (i = 0; i < sizeof(cam_obj) / sizeof(cam_obj[0]); i++)
    {
        cam_obj[i].parent.type               = RT_Device_Class_Miscellaneous;
        cam_obj[i].parent.rx_indicate        = RT_NULL;
        cam_obj[i].parent.tx_complete        = RT_NULL;
        cam_obj[i].parent.init               = rt_hm_init;
        cam_obj[i].parent.open               = rt_hm_open;
        cam_obj[i].parent.close              = RT_NULL;
        cam_obj[i].parent.read               = rt_hm_read;
        cam_obj[i].parent.write              = rt_hm_write;
        cam_obj[i].parent.user_data          = RT_NULL;
        
        struct rt_i2c_bus_device *bus = rt_i2c_bus_device_find(cam_obj[i].i2c_bus_name);
        
        RT_ASSERT(bus != RT_NULL);
        
        cam_obj[i].bus = bus;
        cam_obj[i].chip_addr = HM_CHIP_ADDR;
        rt_device_register(&cam_obj[i].parent, cam_obj[i].name, RT_DEVICE_FLAG_RDWR);   
    }

    return RT_EOK;
}



